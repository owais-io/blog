---
title: "Docker Networking Fundamentals - Part 2: Custom Networks, DNS Resolution, and Network Management"
description: "Master advanced Docker networking with custom bridge networks, automatic DNS resolution, network isolation, port mapping, and comprehensive network management. Learn to build scalable container architectures."
date: "2025-09-12T15:00:00.000Z"
tags: ["docker", "custom-networks", "dns-resolution", "network-isolation", "port-mapping", "network-management"]
published: true
author: "Owais"
category: "Docker"
seo:
  canonical: "https://owais.io/blog/docker-networking-fundamentals-part2"
  keywords: ["docker custom networks", "docker dns resolution", "network isolation", "port mapping", "docker network management", "container networking advanced"]
toc: true
---

Building on Part 1's foundation, we'll now explore advanced Docker networking concepts including custom networks, automatic DNS resolution, network isolation, and comprehensive network management strategies for production environments.

<Callout type="info">
üéØ **What You'll Learn**: In this advanced networking tutorial, you'll discover:
- Creating and configuring custom Docker networks
- Automatic DNS resolution and service discovery
- Network isolation and security patterns
- Port mapping for external connectivity
- Managing multiple networks and container connections
- Network cleanup and maintenance strategies
- Best practices for production container networking

**Time to read**: ~15 minutes | **Difficulty**: Intermediate to Advanced
</Callout>

## üöÄ Advanced Docker Networking Architecture

Custom Docker networks provide enhanced features over the default bridge network, including automatic DNS resolution, better isolation, and more granular control over container communication patterns.

<div className="bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-blue-900 dark:to-indigo-900 p-6 rounded-lg my-6">

### Prerequisites

Before we begin, make sure you have:
- Completed [Part 1: Bridge Networks and Container Communication](https://owais.io/blog/docker-networking-fundamentals-part1)
- Understanding of basic Docker networking concepts
- Familiarity with DNS and IP networking concepts
- Docker installed and running with no existing test containers

</div>

## üèóÔ∏è Step 1: Creating Custom Docker Networks

Custom networks provide several advantages over the default bridge network, including automatic DNS resolution and enhanced isolation.

### Creating a Basic Custom Network

```bash title="Create Custom Application Network"
docker network create app-network
```

Docker creates the custom network and returns its ID:

```bash
c45c3893d969b07c2c76898ee5f8fec9cb01f09e21fafd0ae74b1246db7a987a
```

### Verifying Network Creation

```bash title="List All Networks"
docker network ls
```

The output now shows our new custom network alongside the defaults:

```bash
NETWORK ID     NAME          DRIVER    SCOPE
c45c3893d969   app-network   bridge    local
10acedb416a3   bridge        bridge    local
4014e1a64d4c   host          host      local
b84fc03ca6b5   none          null      local
```

**Network Comparison:**

<table>
<thead>
<tr>
<th>Network</th>
<th>Type</th>
<th>Features</th>
<th>Best Use Case</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>bridge (default)</strong></td>
<td>Default</td>
<td>IP-based communication only</td>
<td>Simple setups, backward compatibility</td>
</tr>
<tr>
<td><strong>app-network (custom)</strong></td>
<td>Custom Bridge</td>
<td>DNS resolution, better isolation</td>
<td>Multi-container applications</td>
</tr>
<tr>
<td><strong>host</strong></td>
<td>Host</td>
<td>Direct host network access</td>
<td>High-performance networking</td>
</tr>
<tr>
<td><strong>none</strong></td>
<td>Null</td>
<td>No networking</td>
<td>Completely isolated containers</td>
</tr>
</tbody>
</table>

### Inspecting Custom Network Configuration

```bash title="Inspect Custom Network"
docker network inspect app-network
```

The inspection reveals the network's automatic configuration:

```json
[
    {
        "Name": "app-network",
        "Id": "c45c3893d969b07c2c76898ee5f8fec9cb01f09e21fafd0ae74b1246db7a987a",
        "Created": "2025-09-12T13:42:56.467893559+05:00",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv4": true,
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": {},
            "Config": [
                {
                    "Subnet": "172.18.0.0/16",
                    "Gateway": "172.18.0.1"
                }
            ]
        },
        "Internal": false,
        "Attachable": false,
        "Ingress": false,
        "ConfigFrom": {
            "Network": ""
        },
        "ConfigOnly": false,
        "Containers": {},
        "Options": {},
        "Labels": {}
    }
]
```

**Key Differences from Default Bridge:**

<table>
<thead>
<tr>
<th>Property</th>
<th>Default Bridge</th>
<th>Custom Network</th>
<th>Advantage</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Subnet</strong></td>
<td>172.17.0.0/16</td>
<td>172.18.0.0/16</td>
<td>Automatic subnet allocation prevents conflicts</td>
</tr>
<tr>
<td><strong>DNS Resolution</strong></td>
<td>No</td>
<td>Yes</td>
<td>Container name-based communication</td>
</tr>
<tr>
<td><strong>Isolation</strong></td>
<td>Limited</td>
<td>Enhanced</td>
<td>Better security and network segmentation</td>
</tr>
<tr>
<td><strong>Configuration</strong></td>
<td>Fixed</td>
<td>Customizable</td>
<td>Flexible subnet and gateway options</td>
</tr>
</tbody>
</table>

## üîß Step 2: Creating Networks with Custom Subnets

For production environments, you may want to specify custom IP ranges and network configurations.

### Creating Network with Custom Subnet

```bash title="Create Network with Specific Subnet"
docker network create --driver bridge --subnet=192.168.100.0/24 custom-subnet-network
```

This creates a network with a specific IP range:

```bash
f7bae93be935b5499189b5ede9c263b1a3b2dd850cb738a72125882c361fa382
```

### Verifying Custom Subnet Network

```bash title="List Networks with Custom Subnet"
docker network ls
```

Output shows the new network:

```bash
NETWORK ID     NAME                    DRIVER    SCOPE
c45c3893d969   app-network             bridge    local
10acedb416a3   bridge                  bridge    local
f7bae93be935   custom-subnet-network   bridge    local
4014e1a64d4c   host                    host      local
b84fc03ca6b5   none                    null      local
```

### Inspecting Custom Subnet Configuration

```bash title="Inspect Custom Subnet Network"
docker network inspect custom-subnet-network
```

The network configuration shows our custom subnet:

```json
[
    {
        "Name": "custom-subnet-network",
        "Id": "f7bae93be935b5499189b5ede9c263b1a3b2dd850cb738a72125882c361fa382",
        "Created": "2025-09-12T13:44:10.084966472+05:00",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv4": true,
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": {},
            "Config": [
                {
                    "Subnet": "192.168.100.0/24"
                }
            ]
        },
        "Internal": false,
        "Attachable": false,
        "Ingress": false,
        "ConfigFrom": {
            "Network": ""
        },
        "ConfigOnly": false,
        "Containers": {},
        "Options": {},
        "Labels": {}
    }
]
```

<Callout type="info">
üí° **Custom Subnet Benefits**: The 192.168.100.0/24 subnet provides 254 usable IP addresses (192.168.100.1-254), perfect for departmental or project-specific container isolation.
</Callout>

## üê≥ Step 3: Deploying Containers to Custom Networks

Let's deploy containers to our custom network and observe the enhanced features.

### Creating Containers on Custom Network

```bash title="Deploy Application Stack" showLineNumbers
docker run -d --name app-server-1 --network app-network nginx:alpine
docker run -d --name app-server-2 --network app-network nginx:alpine  
docker run -d --name app-client --network app-network alpine:latest sleep 3600
```

Output confirms successful deployment:

```bash
# app-server-1
a4ae5c5613f626f853f041cd9e11a6cf9803f3195e53c468139d0229a8c7e3c1

# app-server-2  
0adc8145ff47297c8034c30de84b885a224bf82a5e0f053f88b547ce384d3e3b

# app-client
88314d61148a39702a97bafa715b5b8f5e83e8b1270116239529dfce542384d8
```

### Testing DNS-Based Communication

Now comes the magic of custom networks - automatic DNS resolution using container names:

```bash title="Test DNS Resolution with Container Names"
docker exec app-client ping -c 3 app-server-1
```

Successful DNS resolution and connectivity:

```bash
PING app-server-1 (172.18.0.2): 56 data bytes
64 bytes from 172.18.0.2: seq=0 ttl=64 time=0.198 ms
64 bytes from 172.18.0.2: seq=1 ttl=64 time=0.096 ms
64 bytes from 172.18.0.2: seq=2 ttl=64 time=0.081 ms

--- app-server-1 ping statistics ---
3 packets transmitted, 3 packets received, 0% packet loss
round-trip min/avg/max = 0.081/0.125/0.198 ms
```

### Testing HTTP Communication with DNS

```bash title="HTTP Request Using Container Name"
docker exec app-client wget -qO- http://app-server-1
```

Successful HTTP communication using the container name:

```html
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
<style>
html { color-scheme: light dark; }
body { width: 35em; margin: 0 auto;
font-family: Tahoma, Verdana, Arial, sans-serif; }
</style>
</head>
<body>
<h1>Welcome to nginx!</h1>
<p>If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.</p>

<p>For online documentation and support please refer to
<a href="http://nginx.org/">nginx.org</a>.<br/>
Commercial support is available at
<a href="http://nginx.com/">nginx.com</a>.</p>

<p><em>Thank you for using nginx.</em></p>
</body>
</html>
```

<Callout type="success">
‚úÖ **DNS Magic**: Custom networks provide automatic DNS resolution, allowing containers to communicate using names instead of IP addresses. This is crucial for dynamic, scalable applications.
</Callout>

## üîí Step 4: Demonstrating Network Isolation

One of the key benefits of custom networks is isolation between different network segments.

### Testing Cross-Network Communication (Should Fail)

Let's test if containers on the custom network can reach containers on the default bridge network:

```bash title="Test Network Isolation"
docker exec app-client ping -c 3 web-server-1
```

This fails as expected, demonstrating network isolation:

```bash
ping: bad address 'web-server-1'
```

**Network Isolation Characteristics:**

<table>
<thead>
<tr>
<th>Source Network</th>
<th>Target Network</th>
<th>Result</th>
<th>Reason</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>app-network</strong></td>
<td>app-network</td>
<td>‚úÖ Success</td>
<td>Same network, DNS resolution works</td>
</tr>
<tr>
<td><strong>app-network</strong></td>
<td>bridge (default)</td>
<td>‚ùå Fails</td>
<td>Different networks, no cross-network communication</td>
</tr>
<tr>
<td><strong>bridge</strong></td>
<td>app-network</td>
<td>‚ùå Fails</td>
<td>Networks are isolated by default</td>
</tr>
<tr>
<td><strong>Same network</strong></td>
<td>Same network</td>
<td>‚úÖ Success</td>
<td>Full communication within network boundaries</td>
</tr>
</tbody>
</table>

### Connecting Container to Multiple Networks

Docker allows containers to connect to multiple networks for hybrid communication patterns:

```bash title="Connect Container to Multiple Networks"
docker network connect app-network alpine-client
```

This command connects the existing `alpine-client` (from the default bridge) to our custom network. The command returns no output on success.

### Verifying Multi-Network Connectivity

```bash title="Inspect Updated Network"
docker network inspect app-network
```

The network now shows `alpine-client` connected:

```json
"Containers": {
    "0adc8145ff47297c8034c30de84b885a224bf82a5e0f053f88b547ce384d3e3b": {
        "Name": "app-server-2",
        "EndpointID": "205ddd0f9d2589f75bd8f4fb3ba7b00b5a4c8103bee69bd15c7e00a7e04f3c84",
        "MacAddress": "0a:47:20:c1:00:df",
        "IPv4Address": "172.18.0.3/16",
        "IPv6Address": ""
    },
    "2b7034890c35344265b6cdfe8dde4237f45ecd59883267ecfa8d39c097ea89fc": {
        "Name": "alpine-client",
        "EndpointID": "3566e3fc83c0c19d102c52b9e3f5a1f0d2c23e117a02c7d72fff0110351c0e42",
        "MacAddress": "ba:10:b4:ca:62:4f",
        "IPv4Address": "172.18.0.5/16",
        "IPv6Address": ""
    },
    "88314d61148a39702a97bafa715b5b8f5e83e8b1270116239529dfce542384d8": {
        "Name": "app-client",
        "EndpointID": "dbc9b7d2dcc27d114cc735b810010e990723efe7ad14bcc4b4f1b74c133883f2",
        "MacAddress": "ae:79:ed:b3:19:7c",
        "IPv4Address": "172.18.0.4/16",
        "IPv6Address": ""
    },
    "a4ae5c5613f626f853f041cd9e11a6cf9803f3195e53c468139d0229a8c7e3c1": {
        "Name": "app-server-1",
        "EndpointID": "4daedfa5b7b07d8996c8f00cfa3e9e6b2c73004172c9ce9a1fa01e6727478b36",
        "MacAddress": "9a:3d:a7:d9:f3:6e",
        "IPv4Address": "172.18.0.2/16",
        "IPv6Address": ""
    }
}
```

### Testing Cross-Network Communication After Connection

```bash title="Test Communication After Multi-Network Connection"
docker exec alpine-client ping -c 3 app-server-1
```

Now the communication works:

```bash
PING app-server-1 (172.18.0.2): 56 data bytes
64 bytes from 172.18.0.2: seq=0 ttl=64 time=0.504 ms
64 bytes from 172.18.0.2: seq=1 ttl=64 time=0.099 ms
64 bytes from 172.18.0.2: seq=2 ttl=64 time=0.149 ms

--- app-server-1 ping statistics ---
3 packets transmitted, 3 packets received, 0% packet loss
round-trip min/avg/max = 0.099/0.250/0.504 ms
```

<Callout type="info">
üí° **Multi-Network Strategy**: Connecting containers to multiple networks enables hybrid architectures where containers can communicate across network boundaries when needed, while maintaining overall network isolation.
</Callout>

## üåê Step 5: Port Mapping and External Connectivity

To make containerized services accessible from outside the Docker host, we use port mapping.

### Creating Container with Port Mapping

```bash title="Deploy Public Web Service"
docker run -d --name web-public --network app-network -p 8080:80 nginx:alpine
```

This creates a container with port 8080 on the host mapped to port 80 in the container:

```bash
c2e44a84a49ffc8a6a9c335ac0222f4d0c859e432784fe06a9a3c40f32576755
```

### Testing External Connectivity

```bash title="Test External Access from Host"
curl http://localhost:8080
```

The curl command successfully retrieves the web page from the host:

```html
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
<style>
html { color-scheme: light dark; }
body { width: 35em; margin: 0 auto;
font-family: Tahoma, Verdana, Arial, sans-serif; }
</style>
</head>
<body>
<h1>Welcome to nginx!</h1>
<p>If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.</p>

<p>For online documentation and support please refer to
<a href="http://nginx.org/">nginx.org</a>.<br/>
Commercial support is available at
<a href="http://nginx.com/">nginx.com</a>.</p>

<p><em>Thank you for using nginx.</em></p>
</body>
</html>
```

### Testing Internal Network Access to Mapped Service

```bash title="Internal Network Access"
docker exec app-client wget -qO- http://web-public
```

The service is also accessible internally by container name:

```html
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
<style>
html { color-scheme: light dark; }
body { width: 35em; margin: 0 auto;
font-family: Tahoma, Verdana, Arial, sans-serif; }
</style>
</head>
<body>
<h1>Welcome to nginx!</h1>
<p>If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.</p>

<p>For online documentation and support please refer to
<a href="http://nginx.org/">nginx.org</a>.<br/>
Commercial support is available at
<a href="http://nginx.com/">nginx.com</a>.</p>

<p><em>Thank you for using nginx.</em></p>
</body>
</html>
```

**Port Mapping Communication Patterns:**

<table>
<thead>
<tr>
<th>Access Type</th>
<th>Method</th>
<th>URL/Command</th>
<th>Use Case</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>External (Host)</strong></td>
<td>Port mapping</td>
<td>http://localhost:8080</td>
<td>Public web services, API access</td>
</tr>
<tr>
<td><strong>Internal (Container Name)</strong></td>
<td>DNS resolution</td>
<td>http://web-public</td>
<td>Service-to-service communication</td>
</tr>
<tr>
<td><strong>Internal (IP)</strong></td>
<td>Direct IP</td>
<td>http://172.18.0.x</td>
<td>Legacy applications, debugging</td>
</tr>
<tr>
<td><strong>Cross-network</strong></td>
<td>Multi-network connection</td>
<td>Various methods</td>
<td>Hybrid architectures</td>
</tr>
</tbody>
</table>

## üßπ Step 6: Network Management and Cleanup

Proper network management is essential for maintaining clean, efficient container environments.

### Disconnecting Containers from Networks

```bash title="Disconnect Container from Network"
docker network disconnect app-network alpine-client
```

This removes the container from the specified network. The command returns no output on success.

### Bulk Container Management

For comprehensive cleanup, Docker provides efficient bulk operations:

```bash title="Stop All Test Containers" 
docker stop web-server-1 web-server-2 alpine-client app-server-1 app-server-2 app-client web-public
```

Output confirms each container is stopped:

```bash
web-server-1
web-server-2
alpine-client
app-server-1
app-server-2
app-client
web-public
```

### Remove All Test Containers

```bash title="Remove All Test Containers"
docker rm web-server-1 web-server-2 alpine-client app-server-1 app-server-2 app-client web-public
```

Container removal confirmation:

```bash
web-server-1
web-server-2
alpine-client
app-server-1
app-server-2
app-client
web-public
```

### Network Cleanup

```bash title="Remove Custom Networks"
docker network rm app-network custom-subnet-network
```

Network removal confirmation:

```bash
app-network
custom-subnet-network
```

### Verifying Clean Environment

```bash title="Verify Cleanup" showLineNumbers
docker network ls
docker ps -a
```

Final verification shows a clean environment:

```bash
# Network list - only defaults remain
NETWORK ID     NAME      DRIVER    SCOPE
10acedb416a3   bridge    bridge    local
4014e1a64d4c   host      host      local
b84fc03ca6b5   none      null      local

# No containers remain
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
```

<Callout type="success">
‚úÖ **Clean Environment**: All test containers and custom networks have been successfully removed, returning the system to its original state.
</Callout>

## üéØ Production Network Management Best Practices

### Network Naming Conventions

<table>
<thead>
<tr>
<th>Pattern</th>
<th>Example</th>
<th>Use Case</th>
<th>Benefits</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Application-based</strong></td>
<td>wordpress-network</td>
<td>Single application stacks</td>
<td>Clear ownership and purpose</td>
</tr>
<tr>
<td><strong>Environment-based</strong></td>
<td>prod-frontend-net</td>
<td>Environment isolation</td>
<td>Deployment safety</td>
</tr>
<tr>
<td><strong>Tier-based</strong></td>
<td>database-tier-net</td>
<td>Multi-tier architectures</td>
<td>Security and performance optimization</td>
</tr>
<tr>
<td><strong>Project-based</strong></td>
<td>project-alpha-net</td>
<td>Development projects</td>
<td>Resource organization</td>
</tr>
</tbody>
</table>

### Security Considerations

1. **Network Segmentation**: Use separate networks for different application tiers
2. **Principle of Least Privilege**: Only connect containers to networks they need
3. **Internal Services**: Keep internal services on private networks without port mapping
4. **Monitoring**: Regularly audit network configurations and connections

### Performance Optimization

1. **Subnet Planning**: Choose appropriate subnet sizes for your use case
2. **Network Driver Selection**: Use appropriate drivers for different scenarios
3. **Resource Limits**: Consider network bandwidth and connection limits
4. **Cleanup Automation**: Implement regular cleanup procedures for unused networks

## üéØ Key Takeaways

<div className="bg-gradient-to-br from-green-50 to-blue-50 dark:from-green-900 dark:to-blue-900 p-6 rounded-lg my-8">

### ‚úÖ Advanced Networking Mastery

1. **Custom Networks**: Provide DNS resolution, better isolation, and enhanced control
2. **Service Discovery**: Container names automatically resolve to IP addresses in custom networks
3. **Network Isolation**: Different networks are isolated by default, enhancing security
4. **Multi-Network Connectivity**: Containers can belong to multiple networks for hybrid architectures
5. **Port Mapping**: Enables external access while maintaining internal DNS-based communication
6. **Network Management**: Proper cleanup and naming conventions are essential for production

</div>

## üìñ Advanced Topics for Further Learning

- **Docker Compose Networking**: Multi-container application networking
- **Overlay Networks**: Multi-host container communication in Docker Swarm
- **Network Policies**: Advanced security and traffic control
- **Custom Network Drivers**: Building specialized networking solutions
- **Container Service Mesh**: Advanced service-to-service communication patterns

---

<Callout type="success">
üéâ **Networking Mastery Complete!** You now understand advanced Docker networking concepts including custom networks, DNS resolution, network isolation, port mapping, and comprehensive network management strategies.
</Callout>

## üí¨ Discussion

I'd love to hear about your advanced Docker networking projects:

- What network architectures have you implemented in production?
- How do you handle service discovery in complex applications?
- What network security patterns do you find most effective?
- Have you worked with multi-host networking scenarios?

**Connect with me**:
- üêô [GitHub](https://github.com/owais-io) - Advanced Docker networking examples and configurations
- üìß [Contact](https://owais.io/contact) - Complex networking architecture discussions

---