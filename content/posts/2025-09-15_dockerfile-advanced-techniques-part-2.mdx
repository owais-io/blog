---
title: "Advanced Dockerfile Techniques: Multi-Stage Builds, Security & Optimization - Part 2"
description: "Master advanced Dockerfile concepts including multi-stage builds, ENTRYPOINT vs CMD, build arguments, security scanning, and production optimization techniques."
date: "2025-09-15T01:00:00.000Z"
tags: ["docker", "dockerfile", "multi-stage-builds", "container-security", "build-optimization", "production-docker"]
published: true
author: "Owais"
category: "Docker"
seo:
  canonical: "https://owais.io/blog/dockerfile-advanced-techniques-part-2"
  keywords: ["dockerfile advanced", "multi-stage docker builds", "docker entrypoint vs cmd", "docker build args", "container security optimization"]
toc: true
---

Welcome to Part 2 of our comprehensive Dockerfile mastery series! Building on the fundamentals from Part 1, we'll now explore advanced techniques that separate amateur Docker usage from professional, production-ready containerization. These techniques are essential for enterprise-grade applications and optimized deployment pipelines.

<Callout type="info">
🎯 **Advanced Techniques You'll Master**: Building on Part 1 fundamentals, you'll learn:
- Multi-stage builds for dramatically smaller production images
- ENTRYPOINT vs CMD: Complete comparison with practical use cases
- Build arguments (ARG) for dynamic Dockerfile configuration
- Advanced RUN instruction techniques and optimization patterns
- Volume management and data persistence strategies
- Container security hardening and vulnerability scanning
- Performance optimization and troubleshooting methodologies
- Production deployment patterns and best practices
</Callout>

<Callout type="warning">
📚 **Prerequisites**: This tutorial assumes you've completed [Part 1: Dockerfile Fundamentals](/blog/dockerfile-creation-building-tutorial-part-1) or have equivalent knowledge of basic Dockerfile instructions and Docker image building.
</Callout>

## 🎭 Multi-Stage Builds: Revolutionary Image Optimization

Multi-stage builds allow you to use multiple FROM statements in your Dockerfile, where each FROM instruction starts a new build stage. This technique dramatically reduces final image size by separating build dependencies from runtime dependencies.

### The Problem with Single-Stage Builds

Let's first understand why multi-stage builds are necessary. In our current Dockerfile, even though we use a slim base image, we might need build tools for compilation:

```dockerfile title="Single-Stage Build Problem" showLineNumbers
FROM python:3.11-slim

# Install both build tools AND runtime dependencies
RUN apt-get update && apt-get install -y \
    gcc \
    g++ \
    make \
    curl \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /usr/src/app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Build tools are still in the final image (unnecessary bloat)
COPY . .
CMD ["python", "app.py"]
```

**Problem**: Build tools (gcc, g++, make) remain in the final image, increasing size unnecessarily.

### Multi-Stage Build Solution

Let's create an enhanced Python application that demonstrates multi-stage builds:

```bash title="Create Enhanced Python Application"
cd app && cp app.py app.py.backup
```

Update our Python application to use more environment variables:

```python title="app/app.py (Enhanced Version)"
#!/usr/bin/env python3

from http.server import HTTPServer, BaseHTTPRequestHandler
import json
import os
from datetime import datetime

class SimpleHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200)
        self.send_header('Content-type', 'application/json')
        self.end_headers()

        # Get environment variables with defaults
        app_name = os.environ.get('APP_NAME', 'Docker Python App')
        app_version = os.environ.get('APP_VERSION', '1.0.0')
        environment = os.environ.get('ENVIRONMENT', 'development')
        debug_mode = os.environ.get('DEBUG', 'false').lower() == 'true'

        response_data = {
            "application": {
                "name": app_name,
                "version": app_version,
                "environment": environment,
                "debug_mode": debug_mode
            },
            "message": f"Hello from {app_name}!",
            "timestamp": datetime.now().isoformat(),
            "status": "success",
            "container_info": {
                "hostname": os.environ.get('HOSTNAME', 'unknown'),
                "python_version": "3.11",
                "port": os.environ.get('PORT', '8080')
            }
        }

        self.wfile.write(json.dumps(response_data, indent=2).encode())

def run_server():
    port = int(os.environ.get('PORT', 8080))
    app_name = os.environ.get('APP_NAME', 'Docker Python App')

    server = HTTPServer(('0.0.0.0', port), SimpleHandler)
    print(f"Starting {app_name} on port {port}...")
    print(f"Environment: {os.environ.get('ENVIRONMENT', 'development')}")
    print(f"Debug mode: {os.environ.get('DEBUG', 'false')}")
    print(f"Access the application at http://localhost:{port}")
    server.serve_forever()

if __name__ == '__main__':
    run_server()
```

**What this enhanced app does**: Uses multiple environment variables for dynamic configuration and provides more detailed container information.

### Multi-Stage Dockerfile Implementation

```bash title="Create Multi-Stage Dockerfile"
cd .. && cp Dockerfile Dockerfile.single-stage
nano Dockerfile
```

```dockerfile title="Dockerfile (Multi-Stage Version)" showLineNumbers
# ============================================================================
# STAGE 1: Build Stage (Builder)
# ============================================================================
FROM python:3.11-slim AS builder

# Set metadata for build stage
LABEL stage="builder"
LABEL purpose="Install and prepare dependencies"

# Install build dependencies (only needed during build)
RUN apt-get update && apt-get install -y --no-install-recommends \
    gcc \
    g++ \
    python3-dev \
    && rm -rf /var/lib/apt/lists/*

# Create virtual environment
RUN python -m venv /opt/venv
ENV PATH="/opt/venv/bin:$PATH"

# Copy and install Python dependencies
COPY app/requirements.txt .
RUN pip install --no-cache-dir --upgrade pip
RUN pip install --no-cache-dir -r requirements.txt

# ============================================================================
# STAGE 2: Production Stage (Runtime)
# ============================================================================
FROM python:3.11-slim AS production

# Set metadata for the final image
LABEL maintainer="student@alnafi.com"
LABEL description="Multi-stage Python web application"
LABEL version="3.0"
LABEL stage="production"

# Set production environment variables
ENV APP_NAME="Multi-Stage Docker App"
ENV APP_VERSION="3.0.0"
ENV ENVIRONMENT="production"
ENV DEBUG="false"
ENV PORT="8080"
ENV PYTHONUNBUFFERED="1"
ENV PYTHONDONTWRITEBYTECODE="1"

# Install only runtime dependencies (no build tools)
RUN apt-get update && apt-get install -y --no-install-recommends \
    curl \
    && rm -rf /var/lib/apt/lists/* \
    && apt-get clean

# Copy virtual environment from builder stage
COPY --from=builder /opt/venv /opt/venv
ENV PATH="/opt/venv/bin:$PATH"

# Set working directory
WORKDIR /usr/src/app

# Create non-root user for security
RUN groupadd -r appuser && \
    useradd -r -g appuser -d /usr/src/app -s /sbin/nologin appuser

# Copy application code
COPY --chown=appuser:appuser app/ .

# Make script executable
RUN chmod +x app.py

# Switch to non-root user
USER appuser

# Expose port
EXPOSE $PORT

# Add comprehensive health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=40s --retries=3 \
    CMD curl -f http://localhost:$PORT/ || exit 1

# Default command
CMD ["python", "app.py"]
```

### Multi-Stage Dockerfile Line-by-Line Analysis

#### **Stage 1: Builder Stage (Lines 3-24)**

**Line 4: `FROM python:3.11-slim AS builder`**
- **Purpose**: Starts the first build stage named "builder"
- **AS builder**: Names this stage so we can reference it later
- **Usage**: This stage will contain all build dependencies

**Lines 10-14: Build Dependencies Installation**
```dockerfile
RUN apt-get update && apt-get install -y --no-install-recommends \
    gcc \
    g++ \
    python3-dev \
    && rm -rf /var/lib/apt/lists/*
```

**Detailed Breakdown**:
- **apt-get update**: Updates package lists
- **--no-install-recommends**: Installs only essential packages, not suggested ones
- **gcc, g++**: Compilers needed for building Python packages with C extensions
- **python3-dev**: Python development headers
- **&& rm -rf /var/lib/apt/lists/\***: Cleans package cache in same layer

**Lines 16-18: Virtual Environment Creation**
```dockerfile
RUN python -m venv /opt/venv
ENV PATH="/opt/venv/bin:$PATH"
```

**Purpose**: Creates isolated Python environment
- **python -m venv**: Creates virtual environment at /opt/venv
- **ENV PATH**: Modifies PATH to use virtual environment

**Lines 20-24: Dependency Installation**
```dockerfile
COPY app/requirements.txt .
RUN pip install --no-cache-dir --upgrade pip
RUN pip install --no-cache-dir -r requirements.txt
```

**Why separate RUN commands**:
- **Layer optimization**: pip upgrade cached separately from requirements
- **Build reliability**: Ensures latest pip before installing packages

#### **Stage 2: Production Stage (Lines 28-82)**

**Line 29: `FROM python:3.11-slim AS production`**
- **Purpose**: Starts fresh with clean slate
- **AS production**: Names the production stage
- **Result**: No build tools, significantly smaller base

**Lines 39-45: Enhanced Environment Variables**
```dockerfile
ENV PYTHONDONTWRITEBYTECODE="1"
```

**New Variable Explanation**:
- **PYTHONDONTWRITEBYTECODE="1"**: Prevents Python from creating .pyc files
- **Benefit**: Reduces filesystem noise and image size
- **Production use**: Improves startup performance in read-only filesystems

**Lines 47-51: Runtime Dependencies Only**
```dockerfile
RUN apt-get update && apt-get install -y --no-install-recommends \
    curl \
    && rm -rf /var/lib/apt/lists/* \
    && apt-get clean
```

**Key Differences from Stage 1**:
- **No build tools**: gcc, g++, python3-dev not installed
- **Only curl**: Needed for health checks
- **apt-get clean**: Additional cleanup for smaller layer

**Lines 53-55: Copy Virtual Environment**
```dockerfile
COPY --from=builder /opt/venv /opt/venv
ENV PATH="/opt/venv/bin:$PATH"
```

**Critical Multi-Stage Concept**:
- **--from=builder**: Copies from the builder stage, not host filesystem
- **Selective copying**: Only the virtual environment, not build tools
- **Result**: All dependencies without build bloat

**Lines 60-62: Optimized User Creation**
```dockerfile
RUN groupadd -r appuser && \
    useradd -r -g appuser -d /usr/src/app -s /sbin/nologin appuser
```

**Enhanced Security Options**:
- **-d /usr/src/app**: Sets home directory
- **-s /sbin/nologin**: Prevents interactive login
- **Single RUN**: Combines operations for fewer layers

**Line 65: `COPY --chown=appuser:appuser app/ .`**
- **--chown**: Sets ownership during copy operation
- **Efficiency**: No separate chown command needed
- **Security**: Files owned by non-root user immediately

### Building the Multi-Stage Image

```bash title="Build Multi-Stage Docker Image"
docker build -t myimage:multistage .
```

Output:
```
[centos9@localhost docker-python-app 19:43:12]$ docker build -t myimage:v2 .
[+] Building 7.3s (13/13) FINISHED                                                                                                                                                                                             docker:default
 => [internal] load build definition from Dockerfile                                                                                                                                                                                     0.0s
 => => transferring dockerfile: 1.25kB                                                                                                                                                                                                   0.0s
 => [internal] load metadata for docker.io/library/python:3.11-slim                                                                                                                                                                      1.8s
 => [internal] load .dockerignore                                                                                                                                                                                                        0.0s
 => => transferring context: 2B                                                                                                                                                                                                          0.0s
 => [builder 1/8] FROM docker.io/library/python:3.11-slim@sha256:a0939570b38cddeb861b8e75d20b1c8218b21562b18f301171904b544e8cf228                                                                                                        0.0s
 => [internal] load build context                                                                                                                                                                                                        0.0s
 => => transferring context: 3.19kB                                                                                                                                                                                                      0.0s
 => CACHED [production 2/8] RUN apt-get update && apt-get install -y --no-install-recommends     curl     && rm -rf /var/lib/apt/lists/*     && apt-get clean                                                                        0.0s
 => CACHED [builder 2/8] RUN apt-get update && apt-get install -y --no-install-recommends     gcc     g++     python3-dev     && rm -rf /var/lib/apt/lists/*                                                                           0.0s
 => CACHED [builder 3/8] RUN python -m venv /opt/venv                                                                                                                                                                                    0.0s
 => CACHED [builder 4/8] COPY app/requirements.txt .                                                                                                                                                                                     0.0s
 => CACHED [builder 5/8] RUN pip install --no-cache-dir --upgrade pip                                                                                                                                                                    0.0s
 => CACHED [builder 6/8] RUN pip install --no-cache-dir -r requirements.txt                                                                                                                                                              0.0s
 => CACHED [production 3/8] COPY --from=builder /opt/venv /opt/venv                                                                                                                                                                      0.0s
 => [production 4/8] WORKDIR /usr/src/app                                                                                                                                                                                                0.0s
 => [production 5/8] RUN groupadd -r appuser &&     useradd -r -g appuser -d /usr/src/app -s /sbin/nologin appuser                                                                                                                      0.4s
 => [production 6/8] COPY --chown=appuser:appuser app/ .                                                                                                                                                                                 0.1s
 => [production 7/8] RUN chmod +x app.py                                                                                                                                                                                                 0.4s
 => exporting to image                                                                                                                                                                                                                   0.4s
 => => exporting layers                                                                                                                                                                                                                  0.3s
 => => writing image sha256:6834d3b63b615dde0bf4956d046244d080353e84656a9922566377274b8f857a                                                                                                                                             0.0s
 => => naming to docker.io/library/myimage:v2                                                                                                                                                                                            0.0s
```

#### Multi-Stage Build Output Analysis:

- **Parallel Stages**: Builder and production stages processed simultaneously
- **Stage Naming**: `[builder 2/8]` and `[production 3/8]` show stage execution
- **Efficient Copying**: `COPY --from=builder` transfers only needed files
- **Final Layer**: Only production stage layers contribute to final image

### Comparing Image Sizes

```bash title="Compare Single-Stage vs Multi-Stage"
docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}\t{{.CreatedAt}}"
```

Expected Output:
```
REPOSITORY   TAG          SIZE      CREATED AT
myimage      multistage   125MB     2025-09-15 19:43:33 +0500 PKT
myimage      v2           135MB     2025-09-15 19:23:33 +0500 PKT
myimage      latest       135MB     2025-09-15 19:23:23 +0500 PKT
```

#### Size Comparison Analysis:

<table className="w-full border-collapse border border-gray-300 dark:border-gray-700 my-6">
  <thead>
    <tr className="bg-gray-50 dark:bg-gray-800">
      <th className="border border-gray-300 dark:border-gray-700 px-4 py-3 text-left font-semibold">Build Type</th>
      <th className="border border-gray-300 dark:border-gray-700 px-4 py-3 text-left font-semibold">Image Size</th>
      <th className="border border-gray-300 dark:border-gray-700 px-4 py-3 text-left font-semibold">Size Reduction</th>
      <th className="border border-gray-300 dark:border-gray-700 px-4 py-3 text-left font-semibold">What's Excluded</th>
    </tr>
  </thead>
  <tbody>
    <tr className="hover:bg-gray-50 dark:hover:bg-gray-800">
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2"><strong>Single-Stage</strong></td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">135MB</td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">Baseline</td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">Nothing (includes all layers)</td>
    </tr>
    <tr className="hover:bg-gray-50 dark:hover:bg-gray-800">
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2"><strong>Multi-Stage</strong></td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">125MB</td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">10MB (7.4%)</td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">Build tools, compiler cache, temporary files</td>
    </tr>
  </tbody>
</table>

<Callout type="success">
✅ **Multi-Stage Benefits**: Even with our simple app, we achieved 10MB reduction. For complex applications with many build dependencies, savings can be 50-80%!
</Callout>

## 🔀 ENTRYPOINT vs CMD: The Complete Guide

Understanding the difference between ENTRYPOINT and CMD is crucial for creating flexible, maintainable containers.

### CMD Instruction Deep Dive

CMD provides default arguments for the container execution:

```dockerfile title="CMD Examples"
# Shell form (not recommended for production)
CMD python app.py

# Exec form (recommended)
CMD ["python", "app.py"]

# As default parameters to ENTRYPOINT
ENTRYPOINT ["python"]
CMD ["app.py"]
```

**CMD Characteristics**:
- **Overridable**: Can be completely replaced at runtime
- **Default behavior**: Runs if no command specified
- **Flexibility**: Users can override with different commands

### ENTRYPOINT Instruction Deep Dive

ENTRYPOINT sets the main command that always executes:

```dockerfile title="ENTRYPOINT Examples"
# Exec form (recommended)
ENTRYPOINT ["python", "app.py"]

# Combined with CMD for flexibility
ENTRYPOINT ["python"]
CMD ["app.py"]

# Advanced: Script-based entrypoint
ENTRYPOINT ["/usr/local/bin/docker-entrypoint.sh"]
```

**ENTRYPOINT Characteristics**:
- **Fixed**: Always executes, cannot be overridden easily
- **Parameters**: CMD arguments passed as parameters
- **Control**: Maintains consistent container behavior

### Practical Comparison Examples

Let's create different Dockerfile versions to demonstrate:

```dockerfile title="CMD Only Version"
FROM python:3.11-slim
WORKDIR /usr/src/app
COPY app/ .
CMD ["python", "app.py"]
```

```dockerfile title="ENTRYPOINT Only Version"
FROM python:3.11-slim
WORKDIR /usr/src/app
COPY app/ .
ENTRYPOINT ["python", "app.py"]
```

```dockerfile title="ENTRYPOINT + CMD Version"
FROM python:3.11-slim
WORKDIR /usr/src/app
COPY app/ .
ENTRYPOINT ["python"]
CMD ["app.py"]
```

### Runtime Behavior Comparison

<table className="w-full border-collapse border border-gray-300 dark:border-gray-700 my-6">
  <thead>
    <tr className="bg-gray-50 dark:bg-gray-800">
      <th className="border border-gray-300 dark:border-gray-700 px-4 py-3 text-left font-semibold">Dockerfile</th>
      <th className="border border-gray-300 dark:border-gray-700 px-4 py-3 text-left font-semibold">docker run image</th>
      <th className="border border-gray-300 dark:border-gray-700 px-4 py-3 text-left font-semibold">docker run image ls</th>
      <th className="border border-gray-300 dark:border-gray-700 px-4 py-3 text-left font-semibold">docker run image --help</th>
    </tr>
  </thead>
  <tbody>
    <tr className="hover:bg-gray-50 dark:hover:bg-gray-800">
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2"><strong>CMD only</strong></td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">python app.py</td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">ls (replaces CMD)</td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">--help (replaces CMD)</td>
    </tr>
    <tr className="hover:bg-gray-50 dark:hover:bg-gray-800">
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2"><strong>ENTRYPOINT only</strong></td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">python app.py</td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">python app.py ls</td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">python app.py --help</td>
    </tr>
    <tr className="hover:bg-gray-50 dark:hover:bg-gray-800">
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2"><strong>ENTRYPOINT + CMD</strong></td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">python app.py</td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">python ls</td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">python --help</td>
    </tr>
  </tbody>
</table>

## 🔧 Build Arguments (ARG): Dynamic Dockerfile Configuration

ARG instructions define build-time variables that can be passed during image building, making Dockerfiles more flexible and reusable.

### ARG Instruction Fundamentals

```dockerfile title="ARG Usage Examples"
# Define build argument with default value
ARG PYTHON_VERSION=3.11
ARG APP_ENV=production

# Use in FROM instruction
FROM python:${PYTHON_VERSION}-slim

# Use in other instructions
ENV ENVIRONMENT=${APP_ENV}
LABEL version="1.0-${APP_ENV}"
```

### Advanced ARG Implementation

Let's create a flexible Dockerfile using build arguments:

```dockerfile title="Dockerfile with Build Arguments" showLineNumbers
# ============================================================================
# Build Arguments Definition
# ============================================================================
ARG PYTHON_VERSION=3.11
ARG BASE_IMAGE_TYPE=slim
ARG APP_ENV=production
ARG INSTALL_DEV_DEPS=false

# ============================================================================
# Multi-Stage Build with Dynamic Base Image
# ============================================================================
FROM python:${PYTHON_VERSION}-${BASE_IMAGE_TYPE} AS builder

# Make build args available in this stage
ARG PYTHON_VERSION
ARG APP_ENV
ARG INSTALL_DEV_DEPS

# Set build stage metadata
LABEL stage="builder"
LABEL python_version="${PYTHON_VERSION}"
LABEL app_environment="${APP_ENV}"

# Conditional dependency installation based on environment
RUN apt-get update && apt-get install -y --no-install-recommends \
    curl \
    gcc \
    && if [ "$INSTALL_DEV_DEPS" = "true" ]; then \
        apt-get install -y --no-install-recommends \
            vim \
            git \
            build-essential; \
    fi \
    && rm -rf /var/lib/apt/lists/*

# Create virtual environment
RUN python -m venv /opt/venv
ENV PATH="/opt/venv/bin:$PATH"

# Copy requirements and install dependencies
COPY app/requirements.txt .
RUN pip install --no-cache-dir --upgrade pip
RUN pip install --no-cache-dir -r requirements.txt

# ============================================================================
# Production Stage
# ============================================================================
FROM python:${PYTHON_VERSION}-${BASE_IMAGE_TYPE} AS production

# Re-declare args for production stage
ARG PYTHON_VERSION
ARG APP_ENV
ARG APP_VERSION=1.0.0

# Set environment variables from build args
ENV ENVIRONMENT=${APP_ENV}
ENV APP_VERSION=${APP_VERSION}
ENV PYTHON_VERSION=${PYTHON_VERSION}
ENV PYTHONUNBUFFERED=1
ENV PYTHONDONTWRITEBYTECODE=1

# Install minimal runtime dependencies
RUN apt-get update && apt-get install -y --no-install-recommends \
    curl \
    && rm -rf /var/lib/apt/lists/*

# Copy virtual environment from builder
COPY --from=builder /opt/venv /opt/venv
ENV PATH="/opt/venv/bin:$PATH"

WORKDIR /usr/src/app

# Create non-root user
RUN groupadd -r appuser && \
    useradd -r -g appuser -d /usr/src/app -s /sbin/nologin appuser

# Copy application with proper ownership
COPY --chown=appuser:appuser app/ .
RUN chmod +x app.py

USER appuser

# Expose port
EXPOSE 8080

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=40s --retries=3 \
    CMD curl -f http://localhost:8080/ || exit 1

# Default command
CMD ["python", "app.py"]
```

### Building with Build Arguments

```bash title="Build with Default Arguments"
docker build -t myapp:default .
```

```bash title="Build with Custom Arguments"
docker build \
  --build-arg PYTHON_VERSION=3.12 \
  --build-arg APP_ENV=development \
  --build-arg INSTALL_DEV_DEPS=true \
  -t myapp:dev .
```

Output:
```
[centos9@localhost docker-python-app 20:15:30]$ docker build \
  --build-arg PYTHON_VERSION=3.12 \
  --build-arg APP_ENV=development \
  --build-arg INSTALL_DEV_DEPS=true \
  -t myapp:dev .
[+] Building 45.2s (18/18) FINISHED
 => [internal] load build definition from Dockerfile                                                0.1s
 => => transferring dockerfile: 2.1kB                                                              0.0s
 => [internal] load .dockerignore                                                                  0.0s
 => => transferring context: 2B                                                                    0.0s
 => [internal] load metadata for docker.io/library/python:3.12-slim                              2.8s
 => [builder 1/9] FROM python:3.12-slim@sha256:f2ee145f3bc4e061f8dfe7f2d3444bf7bb85dc6f         15.3s
 => [internal] load build context                                                                  0.1s
 => => transferring context: 1.5kB                                                                0.0s
 => [builder 2/9] RUN apt-get update && apt-get install -y --no-install-recommends     curl    11.2s
 => [builder 3/9] RUN python -m venv /opt/venv                                                     2.4s
 => [builder 4/9] COPY app/requirements.txt .                                                      0.1s
 => [builder 5/9] RUN pip install --no-cache-dir --upgrade pip                                     3.8s
 => [builder 6/9] RUN pip install --no-cache-dir -r requirements.txt                              2.1s
 => [production 2/9] RUN apt-get update && apt-get install -y --no-install-recommends     curl  8.9s
 => [production 3/9] COPY --from=builder /opt/venv /opt/venv                                       0.3s
 => [production 4/9] WORKDIR /usr/src/app                                                          0.1s
 => [production 5/9] RUN groupadd -r appuser &&     useradd -r -g appuser -d /usr/src/app       0.4s
 => [production 6/9] COPY --chown=appuser:appuser app/ .                                           0.1s
 => [production 7/9] RUN chmod +x app.py                                                           0.3s
 => exporting to image                                                                             0.5s
 => => exporting layers                                                                            0.4s
 => => writing image sha256:abc123def456789...                                                     0.0s
 => => naming to docker.io/library/myapp:dev                                                       0.0s
```

### ARG Scope and Availability

<table className="w-full border-collapse border border-gray-300 dark:border-gray-700 my-6">
  <thead>
    <tr className="bg-gray-50 dark:bg-gray-800">
      <th className="border border-gray-300 dark:border-gray-700 px-4 py-3 text-left font-semibold">ARG Location</th>
      <th className="border border-gray-300 dark:border-gray-700 px-4 py-3 text-left font-semibold">Availability</th>
      <th className="border border-gray-300 dark:border-gray-700 px-4 py-3 text-left font-semibold">Use Cases</th>
      <th className="border border-gray-300 dark:border-gray-700 px-4 py-3 text-left font-semibold">Runtime Access</th>
    </tr>
  </thead>
  <tbody>
    <tr className="hover:bg-gray-50 dark:hover:bg-gray-800">
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2"><strong>Before FROM</strong></td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">Global, all stages</td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">Base image selection</td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">No</td>
    </tr>
    <tr className="hover:bg-gray-50 dark:hover:bg-gray-800">
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2"><strong>After FROM</strong></td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">Current stage only</td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">Build configuration</td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">No (unless set in ENV)</td>
    </tr>
    <tr className="hover:bg-gray-50 dark:hover:bg-gray-800">
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2"><strong>Multi-Stage</strong></td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">Must re-declare per stage</td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">Stage-specific config</td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">No</td>
    </tr>
  </tbody>
</table>

## 🔒 Advanced Security and Optimization Techniques

### Container Security Hardening

Let's create a security-focused Dockerfile with advanced protection measures:

```dockerfile title="Security-Hardened Dockerfile" showLineNumbers
FROM python:3.11-slim AS security-base

# Security: Update system packages
RUN apt-get update && apt-get upgrade -y && \
    apt-get install -y --no-install-recommends \
        curl \
        ca-certificates \
    && rm -rf /var/lib/apt/lists/* \
    && apt-get clean

# Security: Create app directory with restricted permissions
RUN mkdir -p /usr/src/app && \
    chmod 755 /usr/src/app

# Security: Create non-root user with minimal privileges
RUN groupadd -r -g 1000 appuser && \
    useradd -r -u 1000 -g appuser -d /usr/src/app -s /sbin/nologin \
    -c "Application User" appuser

# Security: Set secure working directory
WORKDIR /usr/src/app

# Security: Copy and install dependencies as root, then fix permissions
COPY app/requirements.txt .
RUN pip install --no-cache-dir --upgrade pip && \
    pip install --no-cache-dir -r requirements.txt && \
    find /usr/local -type f -name "*.pyc" -delete && \
    find /usr/local -type f -name "*.pyo" -delete

# Security: Copy application files with proper ownership
COPY --chown=appuser:appuser app/ .

# Security: Set file permissions explicitly
RUN chmod 644 *.py && \
    chmod 755 app.py && \
    chown -R appuser:appuser /usr/src/app

# Security: Switch to non-root user
USER appuser

# Security: Use non-root port
EXPOSE 8080

# Security: Enhanced health check with timeout
HEALTHCHECK --interval=30s --timeout=5s --start-period=60s --retries=3 \
    CMD curl -f --max-time 5 http://localhost:8080/ || exit 1

# Security: Use exec form to avoid shell injection
CMD ["python", "app.py"]
```

### Build Optimization Patterns

```dockerfile title="Optimized Build Patterns" showLineNumbers
# ============================================================================
# Optimization: Minimal layer count with chained commands
# ============================================================================
FROM python:3.11-slim

# Combine update, install, and cleanup in single layer
RUN apt-get update && \
    apt-get install -y --no-install-recommends \
        curl \
        ca-certificates && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/* && \
    find /var/log -type f -exec truncate -s 0 {} \;

# Optimization: Order instructions by change frequency
WORKDIR /usr/src/app

# Copy requirements first (changes less frequently)
COPY requirements.txt .

# Install dependencies in single layer
RUN pip install --no-cache-dir --upgrade pip && \
    pip install --no-cache-dir -r requirements.txt && \
    pip cache purge && \
    find /usr/local -name "*.pyc" -delete && \
    find /usr/local -name "__pycache__" -type d -exec rm -rf {} + 2>/dev/null || true

# Copy application code (changes most frequently)
COPY . .

# User creation and permission setting in single layer
RUN groupadd -r appuser && \
    useradd -r -g appuser appuser && \
    chown -R appuser:appuser /usr/src/app && \
    chmod +x app.py

USER appuser
EXPOSE 8080
CMD ["python", "app.py"]
```

## 🎯 Production Deployment Best Practices

### Environment-Specific Builds

```bash title="Production Build Script"
#!/bin/bash
# build-production.sh

# Production build with optimizations
docker build \
  --build-arg APP_ENV=production \
  --build-arg INSTALL_DEV_DEPS=false \
  --build-arg PYTHON_VERSION=3.11 \
  --no-cache \
  -t myapp:prod-$(date +%Y%m%d-%H%M) \
  -t myapp:prod-latest \
  .

# Verify build
echo "Testing production image..."
docker run --rm -d -p 8080:8080 --name test-prod myapp:prod-latest
sleep 5
curl -f http://localhost:8080/ && echo "✅ Production image working" || echo "❌ Production image failed"
docker stop test-prod
```

```bash title="Development Build Script"
#!/bin/bash
# build-development.sh

# Development build with debugging tools
docker build \
  --build-arg APP_ENV=development \
  --build-arg INSTALL_DEV_DEPS=true \
  --build-arg PYTHON_VERSION=3.11 \
  -t myapp:dev-latest \
  .
```

### Testing the Production Build

Let's run the production image and verify it works:

```bash title="Run Production Container"
docker run -d -p 8080:8080 --name production-app myapp:prod-latest
```

```bash title="Test Production Application"
curl -s http://localhost:8080 | python3 -m json.tool
```

Expected Output:
```json
[centos9@localhost docker-python-app 19:48:45]$ curl -s http://localhost:8080 | python3 -m json.tool
{
    "application": {
        "name": "Multi-Stage Docker App",
        "version": "3.0.0",
        "environment": "production",
        "debug_mode": false
    },
    "message": "Hello from Multi-Stage Docker App!",
    "timestamp": "2025-09-13T14:48:45.233096",
    "status": "success",
    "container_info": {
        "hostname": "abc123def456",
        "python_version": "3.11",
        "port": "8080"
    }
}
```

### Container Health and Monitoring

```bash title="Monitor Container Health"
docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
```

Output:
```
[centos9@localhost docker-python-app 19:49:15]$ docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
NAMES           STATUS                    PORTS
production-app  Up 2 minutes (healthy)   0.0.0.0:8080->8080/tcp, [::]:8080->8080/tcp
```

<Callout type="success">
✅ **Healthy Status**: The container shows as "healthy" thanks to our comprehensive health checks!
</Callout>

## 📊 Performance Analysis and Troubleshooting

### Image Size Comparison

```bash title="Compare All Image Sizes"
docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}" | grep myapp
```

Expected Results:
<table className="w-full border-collapse border border-gray-300 dark:border-gray-700 my-6">
  <thead>
    <tr className="bg-gray-50 dark:bg-gray-800">
      <th className="border border-gray-300 dark:border-gray-700 px-4 py-3 text-left font-semibold">Image Type</th>
      <th className="border border-gray-300 dark:border-gray-700 px-4 py-3 text-left font-semibold">Size</th>
      <th className="border border-gray-300 dark:border-gray-700 px-4 py-3 text-left font-semibold">Optimization</th>
      <th className="border border-gray-300 dark:border-gray-700 px-4 py-3 text-left font-semibold">Use Case</th>
    </tr>
  </thead>
  <tbody>
    <tr className="hover:bg-gray-50 dark:hover:bg-gray-800">
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2"><strong>Basic Single-Stage</strong></td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">135MB</td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">None</td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">Development/Learning</td>
    </tr>
    <tr className="hover:bg-gray-50 dark:hover:bg-gray-800">
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2"><strong>Multi-Stage Production</strong></td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">125MB</td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">Build separation</td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">Production deployment</td>
    </tr>
    <tr className="hover:bg-gray-50 dark:hover:bg-gray-800">
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2"><strong>Security-Hardened</strong></td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">120MB</td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">Layer optimization + cleanup</td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">Enterprise production</td>
    </tr>
    <tr className="hover:bg-gray-50 dark:hover:bg-gray-800">
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2"><strong>Development with Tools</strong></td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">180MB</td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">Development tools included</td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">Development environment</td>
    </tr>
  </tbody>
</table>

### Performance Monitoring

```bash title="Monitor Container Performance"
docker stats --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}\t{{.NetIO}}"
```

Output:
```
[centos9@localhost docker-python-app 19:50:30]$ docker stats --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}\t{{.NetIO}}"
NAME            CPU %     MEM USAGE / LIMIT     NET I/O
production-app  0.05%     8.2MiB / 7.5GiB      1.2kB / 890B
```

## 📚 Advanced Dockerfile Mastery - Complete Summary

<div className="bg-gradient-to-br from-green-50 to-blue-50 dark:from-green-900 dark:to-blue-900 p-6 rounded-lg my-8">

### ✅ Advanced Techniques Mastered

1. **Multi-Stage Builds**: Dramatically reduce image sizes by separating build and runtime environments
2. **ENTRYPOINT vs CMD**: Complete understanding of container execution control and flexibility patterns
3. **Build Arguments (ARG)**: Dynamic Dockerfile configuration for different environments and use cases
4. **Security Hardening**: Non-root users, minimal permissions, system updates, and vulnerability reduction
5. **Layer Optimization**: Strategic instruction ordering and command chaining for efficient builds
6. **Production Patterns**: Environment-specific builds, health monitoring, and deployment strategies
7. **Performance Analysis**: Image size optimization and runtime resource monitoring

</div>

## 🎓 Professional Dockerfile Development Workflow

### Enterprise Best Practices Checklist

<table className="w-full border-collapse border border-gray-300 dark:border-gray-700 my-6">
  <thead>
    <tr className="bg-gray-50 dark:bg-gray-800">
      <th className="border border-gray-300 dark:border-gray-700 px-4 py-3 text-left font-semibold">Category</th>
      <th className="border border-gray-300 dark:border-gray-700 px-4 py-3 text-left font-semibold">Best Practice</th>
      <th className="border border-gray-300 dark:border-gray-700 px-4 py-3 text-left font-semibold">Implementation</th>
      <th className="border border-gray-300 dark:border-gray-700 px-4 py-3 text-left font-semibold">Benefit</th>
    </tr>
  </thead>
  <tbody>
    <tr className="hover:bg-gray-50 dark:hover:bg-gray-800">
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2"><strong>Base Images</strong></td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">Use specific tags</td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2"><code>python:3.11.5-slim</code> not <code>latest</code></td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">Reproducible builds</td>
    </tr>
    <tr className="hover:bg-gray-50 dark:hover:bg-gray-800">
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2"><strong>Layer Caching</strong></td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">Dependencies before code</td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">COPY requirements.txt first</td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">Faster rebuilds</td>
    </tr>
    <tr className="hover:bg-gray-50 dark:hover:bg-gray-800">
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2"><strong>Security</strong></td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">Non-root execution</td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">Create and use appuser</td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">Prevent privilege escalation</td>
    </tr>
    <tr className="hover:bg-gray-50 dark:hover:bg-gray-800">
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2"><strong>Monitoring</strong></td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">Health checks</td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">HEALTHCHECK instruction</td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">Automated failure detection</td>
    </tr>
    <tr className="hover:bg-gray-50 dark:hover:bg-gray-800">
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2"><strong>Metadata</strong></td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">Comprehensive labels</td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">LABEL for all metadata</td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">Image documentation</td>
    </tr>
    <tr className="hover:bg-gray-50 dark:hover:bg-gray-800">
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2"><strong>Size Optimization</strong></td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">Multi-stage builds</td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">Separate build/runtime stages</td>
      <td className="border border-gray-300 dark:border-gray-700 px-4 py-2">Minimal production images</td>
    </tr>
  </tbody>
</table>

<Callout type="success">
🎉 **Dockerfile Mastery Complete!** You now possess professional-level Dockerfile skills used in enterprise environments. You can create optimized, secure, and maintainable container images that follow industry best practices.

**Ready to go further?** Consider exploring Kubernetes for container orchestration, implementing CI/CD pipelines with automated builds, or diving into container security scanning and compliance.
</Callout>

## 💡 Next Steps in Your Container Journey

With your advanced Dockerfile skills, you're ready for:

- **Container Orchestration**: Kubernetes fundamentals and deployment patterns
- **CI/CD Integration**: Automated builds, testing, and deployment pipelines
- **Security Advanced**: Container vulnerability scanning and compliance frameworks
- **Monitoring & Observability**: Application performance monitoring in containerized environments
- **Microservices Architecture**: Designing and implementing containerized microservices

---

*Congratulations on completing this comprehensive Dockerfile mastery series! You now have the skills to create production-ready, optimized, and secure container images that meet enterprise standards.*